## 2021.08.09 실전자바개발 2장



1. 목표

   - 입출금내역분석기를 구현해서 SRP, 결합도, 응집도 같은 핵심개념으로 객체지향 프로그래밍에 대해 배워보자

     <br>

     <br>

     <br>

2. KISS 원칙

   - keep it short and simple

     - 소프트웨어 설계에서 간단하고 알기 쉽게 만드는 편이 좋다는 원칙이다

     <br>

     <br>

     <br>

3. final 변수

   - 지역변수나 필드에 final 키워드를 사용하면 이 변수에 값을 재할당할 수 없다

     - 하지만 final 키워드를 적용한다고 해서 객체가 바뀌지 못 하도록 강요하는 것은 아니다

     - final 키워드로 가리키는 객체라도 가변성(mutable state)을 포함하기 때문이다

       <BR>

   - final 키워드가 무가치한 상황

     - 추상 메소드의 파라미터(인자값)에 final을 사용하는 상황은 실제로 구현하지 않은 추상 메소드이기때문에 의미없다
     - 자바 10에서 var 키워드가 등장하면서 final의 유용성은 점차 감소했다

     <br>

     <br>

     <br>

4. 코드 유지보수성과 안티패턴

   - 코드 유지보수성은 추후에 프로그램의 유지/보수를 위해 확장성있고, 쉽게 이해할 수 있는 코드의 성질을 의미한다

   - 갓클래스

     - 한 개의 파일에 모든 코드를 구현하다보면 나오는 거대하고 복잡한 클래스

       - 추후에 수정/추가 작업 시에 복잡한 형태로 인해 능률이 매우 떨어지게 됨

       - 이를 해결하기 위한 다양한 방법 중에 하나는 SRP(단일책임원칙)를 충족시킨 클래스를 작성하는 것

         <BR>

   - 코드중복

     - 같은 기능을 하지만 종류에 따라 다른 코드를 작성해야한다면 이는 코드중복이 될 가능성이 높다
     - 이를 해결하기 위해 제네릭 등의 함수들을 이용해서 포용적인 코드를 짜는 것을 추천한다
     - DRY(Don't Repeat Yourself)
       - 반복을 제거하면 로직을 바꿔도 여러 곳의 코드를 수정할 필요가 없어진다

     <br>

     <br>

     <br>

5. 단일책임원칙(SRP)

   - 모든 클래스는 단 하나의 책임만을 가지도록 설계해야한다

     - 클래스에 책임을 할당할 때, 당연히 그 책임을 수행해야하는 클래스에게 할당해야 한다

     - 즉 클래스가 변경되어야하는 이유가 무조건 하나만 되도록 설계해야 한다

     - 일반적으로 클래스와 메소드에 적용된다

       <BR>

   - 예시

     - 입력을 읽어오면  주어진 형식의 입력파싱해서 결과를 처리하고 결과 요약 리포트 작성을 하는 클래스가 존재한다면

     - 입력읽기, 주어진 형식의 입력 파싱하기, 결과처리하기, 결과 요약 리포트 작성이라는 4가지로 나눈다

       <BR>

       <BR>

       <BR>

6. 응집도(Cohension)

   - 모듈 내부 요소들의 서로 관련되어 있는 정도

     - 즉, 클래스나 메소드의 책임이 얼마나 강하게 연결된 정도

       <BR>

   - 응집도가 높을수록 좋은 프로그램이라고 본다

     <BR>

   - 종류(밑으로 내려갈수록 응집도가 높아짐, 우수한 프로그램)

     - 우연적 응집도(Coincidental Cohesion)
       - 모듈 내부의 각 구성요소들이 연관이 없을 경우
     - 논리적 응집도(Logical Cohesion)
       - 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우
     - 시간적 응집도(Temporal Cohesion)
       - 연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우
     - 절차적 응집도(Procedural Cohesion)
       - 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성요소들이 그 기능을 순차적으로 수행할 경우
     - 통신적 응집도(Communication Cohesion)
       - 동일한 입력과 출력을 사용하여 다른 기능을 수행하는 활동들이 모여있을 경우
     - 순차적 응집도(Sequential Cohesion)
       - 모듈 내에서 한 활동으로 부터 나온 출력값을 다른 활동이 사용할 경우
     - 기능적(Functional Cohesion)
       - 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우

     <br>

     <br>

     <br>

7. 결합도(Coupling)

   - 모듈 외부 요소들의 서로 관련되어 있는 정도 

     - 즉, 한 클래스의 기능(메소드, 필드 등)이 다른 클래스에 얼마나 의존하고 있는가

       <BR>

   - 결합도가 낮을수록 좋은 프로그램이라고 본다

     <BR>

   - 종류(밑으로 내려갈수록 결합도가 내려감, 우수한 프로그램)

     - 내용

       - 하나의 모듈이 다른 모듈의 내부 동작을 수정하거나 내부 동작에 의존하는 경우(다른 클래스의 지역변수를 참조하는 경우)

     - 공통

       - 두 개의 모듈이 같은 글로벌 데이터를 공유하는 경우(전역 변수를 같이 사용하는 경우)

     - 외부

       - 두 개의의 모듈이 외부에서 도입된 데이터 포맷, 통신 프로토콜, 또는 디바이스 인터페이스를 공유하는 경우

     - 제어

       - 하나의 모듈이 다른 모듈으로 무엇을 해야하는지에 대한 정보를 넘겨줌으로써 다른 모듈의 흐름을 제어하는 경우

     - 스탬프

       - 모듈들이 데이터 구조를 공유하고, 그 서로 다른 일부만을 사용하는 경우

     - 자료

       - 모듈들이 메소드 등의 파라미터 등을 통해 데이터를 공유하는 경우

         <BR>

   - 결합도를 낮추는 방법

     - 다형성을 이용하기
       - 두 객체 간에 직접적인 관계를 주지말고 중간에 인터페이스를 넣어서 확장성에 집중해서 구현한다
     - 디자인패턴 이용하기
       - 기존에 만들어진 GoF 디자인패턴 23가지를 이용한다. 예를 들어, 팩토리 메소드 패턴!
     - Spring 같은 외부 프레임워크를 이용하기
       - *의존성 주입(DI) 등을 통해 작성한다(어려운 내용이고 아직 안 배웠으니 추후에 다시 공부하자)*

     <br>

     <br>

     <br>

8. 테스트(Unit Test)

   - Unit Test는 컴퓨터 프로그래밍에서 소스 코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증하는 절차다. 
     - 즉, 모든 함수와 메소드에 대한 테스트 케이스를 작성하는 절차를 말한다

   - 테스트 자동화

     - 우리가 처음에 개발을 완성했을 때 SW가 처음부터 제대로 작동할 확률은 매우 적다
     - 이를 해결하기 위해 테스트를 진행하고, 인간이 모든 오류에 대한 테스트케이스를 검사하는 것이 어렵기 때문에 테스트 자동화를 개발했다

   - 장점

     - 확신

       - SW가 요구사항과 일치하며 동작하는지 테스트할 수 있다

     - 변화에도 튼튼함을 유지

       - 새로 바꾼 코드에 의해서 새로운 버그가 나올 확률이 적다

     - 프로그램 이해도

       - 거대한 프로그램의 소스코드에서 다양한 컴포넌트가 어떻게 상호작용하는지 알 수 있다

         <BR>

   - 제이유닛(JUnit) 사용하기

     - 제이유닛(JUnit)은 자바 기반의 테스트 자동화 프레임워크이다

       - 주로 테스트 클래스 이름에는 `Test`라는 접미어를 붙인다
       - 테스크 메소드 구현 시, 서술형으로 무슨 테스트를 하는지 쉽게 알 수 있도록한다
       - 제이유닛의 annotation인 `@Test`를 테스트 메소드에 추가한다
       - 테스트 메소드의 구현부(body)에 `Assert.fail("Error")`를 호출해서 메소드를 실행하면 "Error"라는 문구와 함께 유닛테스트가 실패한다

     - Given-When-Then

       - 테스트의 컨텍스트를 설정한다

       - 동작을 실행한다

       - 예상된 결과를 어서션(Assertion)으로 지정한다

         <br>

   - 코드 커버리지

     - 코드 커버리지는 테스트집합이 SW의 소스코드를 얼마나 테스트했는가 알려주는 척도이다
     - 코드 커버리지가 높을 수록 예상하지 못한 버그가 나올 확률을 줄이므로 좋은 프로그램을 만들 수 있다
     - 주로 70~90%를 목표로 한다

     <br>

     <br>

     <br>

