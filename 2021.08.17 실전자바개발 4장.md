## 2021.08.17 실전자바 소프트웨어개발 4장



1. 목표

   - 문서 관리 시스템을 설계하기 위해 상속관계를 어떻게 구현하느냐를 배워본다

     - LSP를 이용하자

       <br>

       <br>

       <br>

2. 문서 관리 시스템 요구사항

   - 기존 환자 정보 파일을 읽어 색인을 추가하고, 검색할 수 있는 형태의 데이터로 변환해야 한다

     <br>

   - 다른 종류의 문서도 추가할 수 있어야 한다

     <br>

     <br>

     <br>

3. 설계 작업

   - Importer 인터페이스

     - 다양한 종류의 문서를 import하는 것이 문서 관리 시스템의 핵심이다. 단순하게 Main클래스에 swich문을 써서 하면 다른 종류의 문서가 생성될 때마다 코드를 추가해야하기 때문에 좋은 방법이 아니다

     - 이를 해결하기 위해 `Importer 인터페이스`를 정의한다

       <br>

   - 파일 경로 

     - String

       - 파일 경로를 문자열로 표현하는 방식

     - java.io.File

       - 파일 경로를 표현하기 위해 직접 '파일'을 가리키는 `strong typed`  방식
       - 오류가 발생할 확률을 줄인다

     - 문서 관리 시스템의 공개API에서는 왜 `java.io.File`방법을 쓰지 않을까?

       - ***공개 API가 다른 종류의 사용자 인터페이스로 감싸진 상태이므로 어떤 파일을 지원해야하는지 알 수 없기 때문이다(질문사항)***

       - 그래서 여기서는 파일 경로를 `String`방식으로 처리한다

         <br>

   - Document 클래스

     - 각 문서는 검색할 수 있는 다양한 속성을 포함한다. 문서의 종류에 따라 포함하는 속성이 달라진다

     - 해결책

       - HashMap<String, String>으로 key, value 한쌍으로 저장하는 방법
         - Document가 HashMap<String, String>을 상속받는다면 응용프로그램이 Document 클래스를 바꿀 수 있게(mutate)한다면 불변성으로 얻는 이익이 없어진다
       - Document를 불변 클래스로 만드는 방법을 추천한다(Importer 인테페이스를 구현하는 방식)

     - Document 속성 및 계층 String 으로 정보를 전달하는 것은 좋지 않은 방법이다(Stringly typed)

       - 일반적으로 정수로 정보를 전달하는 것을 추천하나 여기는 문서관리시스템이므로 문자열로 전달한다

     - 문서의 각 서브클래스가 전용필드를 갖기 않도록 모든 알려진 속성을 범용처리한다

       - 각 문서는 자신과 관련된 동작을 거의 포함하지 않는다 -> KISS 원칙

         <br>

         <br>

         <br>

4. 리스코프 치환 원칙(LSP)

   - 일반화 관계는 상위 클래스(수퍼 클래스)가 제공하는 오퍼레이션과 하위 클래스(파생 클래스)에서 제공하는 오퍼레이션 간에는 행위적으로 일관성이 있어야한다는 원칙

     - 부모 클래스가 허용하지 않은 상태 변화를 자식 클래스가 허용할 수 없다

       <br>

   - 이 두 가지 조건을 만족하면 수퍼, 파생 클래스 간에 일관성이 있다고 한다

     - PRE_SUPER -> PRE_SUB

     - POST_SUB -> POST_SUPER

     - 예를 들어, 부모가 문서 크기를 제한하지 않았다면, 자식 클래스는 문서 크기가 100MB 이하라고 요구할 수 없다

       <br>

       <br>

       <br>

5. 대안

   - Importer를 클래스로 만들기

     - 문서 관리 시스템에서는 맞지않는 경우지만, 꼭 모든 부모를 인터페이스로 만드는 것이 올바른 것이 아니다(케바케)

     - `is a 관계`처럼 직접적인 연관관계를 모델링한다면 '상속'이 올바른 결정이지만 그외에는 인터페이스를 추천

       <br>

   - 영역, 캡슐화 선택하기

     - Importer 인터페이스, Query 클래스는 모두 `default 접근자`이므로 패키지 영역 안에서만 접근이 가능하다

     - `default 접근자`를 통해 캡슐화가 가능해서 클래스가 외부로 노출되지 않고, 내부 설계를 쉽게 바꿀 수 있다

       <br>

       <br>

       <br>

6. 기존 코드 확장과 재사용

   - 유틸리티 클래스 사용

     - `ImportUtil`이라는 클래스를 생성해서 공통기능을 모두 만들고, 서브클래스에서 메소드를 재사용하는 방법

     - 갓클래스가 될 가능성이 있으므로 문서 관리 시스템에서는 적절치 않음

       <br>

   - 상속 사용

     - `TextImporter`라는 클래스를 생성해서 상속받는 방법이다

     - 상속 관계가 아닌 관계를 억지로 상속으로 구현하든가 아니면 시간이 흐르면서 관계가 바뀌는 경우 좋지 못 한 방법이다

       <br>

   - **도메인 클래스 사용**

     - 텍스트 파일을 도메인 클래스로 모델링하는 방법

       - 기본 개념을 모델링하고, 기본 개념이 제공하는 메소드를 호출해서 다양한 Importer를 만든다

     - 문서가 항상 텍스트파일이라는 보장이 없으므로 Document의 자식클래스로 만들지 않고 기본 클래스로 `TextFile`을 생성한다

       - `TextFile`클래스에는 텍스트 파일에서 데이터를 추출하는 메소드를 포함한다

         <br>

         <br>

         <br>

7. 테스트 위생

   - 테스트 위상이란?

     - 테스트 대상 코드베이스뿐 아니라 테스트 코드도 깔끔하게 유지 및 보수하고 개선해야함을 의미

   - 테스트 이름 짓기

     - 도메인 용어 사용

       - 문제 도메인을 설명하거나 응용프로그램에서 문제를 지칭할 때 사용하는 용어를 사용

     - 자연어 사용 

       - 일반 문장처럼 읽을 수 있어야 한다. 테스트 이름은 항상 어떤 동작을 쉽게 이해할 수 있도록 묘사해야 한다

     - 서술적으로 작성 

       <br>

       <br>

       <br>

8. 질문 

   - 공개 API가 다른 종류의 사용자 인터페이스로 감싸진 상태이므로 어떤 파일을 지원해야하는지 알 수 없기 때문이다
     - 감싼다는 말이 무슨 의미일까?
   - `default 접근자`를 통해 캡슐화가 가능해서 클래스가 외부로 노출되지 않고, 내부 설계를 쉽게 바꿀 수 있다
     - 패키지 영역에서만 접근이 가능하기 때문에 내부 설계를 쉽게 바꿀 수 있다는 것은 단순한 영역의 문제 때문에 그런 것인가? 다른 의미가 있는 것인가?